//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.9.0, generator: @autorest/go@4.0.0-preview.43)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package dataprotectiondatasourceplugin

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AdhocBasedTaggingCriteria.
func (a AdhocBasedTaggingCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tagInfo", a.TagInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdhocBasedTaggingCriteria.
func (a *AdhocBasedTaggingCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tagInfo":
				err = unpopulate(val, "TagInfo", &a.TagInfo)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AdhocBasedTriggerContext.
func (a AdhocBasedTriggerContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "AdhocBasedTriggerContext"
	populate(objectMap, "taggingCriteria", a.TaggingCriteria)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdhocBasedTriggerContext.
func (a *AdhocBasedTriggerContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "taggingCriteria":
				err = unpopulate(val, "TaggingCriteria", &a.TaggingCriteria)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoHealSettings.
func (a AutoHealSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoHealStatus", a.AutoHealStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoHealSettings.
func (a *AutoHealSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoHealStatus":
				err = unpopulate(val, "AutoHealStatus", &a.AutoHealStatus)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBackupParams.
func (a AzureBackupParams) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupType", a.BackupType)
	objectMap["objectType"] = "AzureBackupParams"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBackupParams.
func (a *AzureBackupParams) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupType":
				err = unpopulate(val, "BackupType", &a.BackupType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBackupParamsForPlugin.
func (a AzureBackupParamsForPlugin) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoHealSettings", a.AutoHealSettings)
	populate(objectMap, "backupType", a.BackupType)
	objectMap["objectType"] = "AzureBackupParamsForPlugin"
	populate(objectMap, "policyInfo", a.PolicyInfo)
	populate(objectMap, "policyParameters", a.PolicyParameters)
	populate(objectMap, "retentionTag", a.RetentionTag)
	populate(objectMap, "triggerType", a.TriggerType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBackupParamsForPlugin.
func (a *AzureBackupParamsForPlugin) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoHealSettings":
				err = unpopulate(val, "AutoHealSettings", &a.AutoHealSettings)
				delete(rawMsg, key)
		case "backupType":
				err = unpopulate(val, "BackupType", &a.BackupType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "policyInfo":
				err = unpopulate(val, "PolicyInfo", &a.PolicyInfo)
				delete(rawMsg, key)
		case "policyParameters":
				err = unpopulate(val, "PolicyParameters", &a.PolicyParameters)
				delete(rawMsg, key)
		case "retentionTag":
				err = unpopulate(val, "RetentionTag", &a.RetentionTag)
				delete(rawMsg, key)
		case "triggerType":
				err = unpopulate(val, "TriggerType", &a.TriggerType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureOperationalStoreParameters.
func (a AzureOperationalStoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataStoreType", a.DataStoreType)
	objectMap["objectType"] = "AzureOperationalStoreParameters"
	populate(objectMap, "resourceGroupId", a.ResourceGroupID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureOperationalStoreParameters.
func (a *AzureOperationalStoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataStoreType":
				err = unpopulate(val, "DataStoreType", &a.DataStoreType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "resourceGroupId":
				err = unpopulate(val, "ResourceGroupID", &a.ResourceGroupID)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupCriteria.
func (b BackupCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = b.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupCriteria.
func (b *BackupCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupDatasourceParameters.
func (b BackupDatasourceParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = b.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupDatasourceParameters.
func (b *BackupDatasourceParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupParameters.
func (b BackupParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = b.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupParameters.
func (b *BackupParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupRequest.
func (b BackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "datasource", b.Datasource)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", b.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", b.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", b.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", b.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupRequest.
func (b *BackupRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &b.AdditionalProperties)
				delete(rawMsg, key)
		case "backupParameters":
				err = unpopulate(val, "BackupParameters", &b.BackupParameters)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &b.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &b.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &b.DatasourceSet)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &b.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &b.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &b.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &b.RPCatalogInitializeParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupRequestBase.
func (b BackupRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "datasource", b.Datasource)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", b.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", b.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", b.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupRequestBase.
func (b *BackupRequestBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &b.AdditionalProperties)
				delete(rawMsg, key)
		case "backupParameters":
				err = unpopulate(val, "BackupParameters", &b.BackupParameters)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &b.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &b.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &b.DatasourceSet)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &b.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &b.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &b.RPCatalogInitializeParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupResponse.
func (b BackupResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", b.Error)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "result", b.Result)
	populate(objectMap, "status", b.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupResponse.
func (b *BackupResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &b.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &b.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupRule.
func (b BackupRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoHealSettings", b.AutoHealSettings)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "objectType", b.ObjectType)
	populate(objectMap, "targetDatastore", b.TargetDatastore)
	populate(objectMap, "trigger", b.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupRule.
func (b *BackupRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoHealSettings":
				err = unpopulate(val, "AutoHealSettings", &b.AutoHealSettings)
				delete(rawMsg, key)
		case "backupParameters":
				b.BackupParameters, err = unmarshalBackupParametersClassification(val)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &b.Name)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		case "targetDatastore":
				err = unpopulate(val, "TargetDatastore", &b.TargetDatastore)
				delete(rawMsg, key)
		case "trigger":
				b.Trigger, err = unmarshalTriggerContextClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupSchedule.
func (b BackupSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "repeatingTimeIntervals", b.RepeatingTimeIntervals)
	populate(objectMap, "timeZone", b.TimeZone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSchedule.
func (b *BackupSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "repeatingTimeIntervals":
				err = unpopulate(val, "RepeatingTimeIntervals", &b.RepeatingTimeIntervals)
				delete(rawMsg, key)
		case "timeZone":
				err = unpopulate(val, "TimeZone", &b.TimeZone)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupSettings.
func (b BackupSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSourceType", b.DataSourceType)
	populate(objectMap, "objectType", b.ObjectType)
	populate(objectMap, "policyName", b.PolicyName)
	populate(objectMap, "policyParameters", b.PolicyParameters)
	populate(objectMap, "rawJsonSetting", b.RawJSONSetting)
	populate(objectMap, "rules", b.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSettings.
func (b *BackupSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSourceType":
				err = unpopulate(val, "DataSourceType", &b.DataSourceType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		case "policyName":
				err = unpopulate(val, "PolicyName", &b.PolicyName)
				delete(rawMsg, key)
		case "policyParameters":
				err = unpopulate(val, "PolicyParameters", &b.PolicyParameters)
				delete(rawMsg, key)
		case "rawJsonSetting":
				err = unpopulate(val, "RawJSONSetting", &b.RawJSONSetting)
				delete(rawMsg, key)
		case "rules":
				err = unpopulate(val, "Rules", &b.Rules)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupStatus.
func (b BackupStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "jobProgressMetadata", b.JobProgressMetadata)
	populate(objectMap, "loopBackContext", b.LoopBackContext)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", b.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", b.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupStatus.
func (b *BackupStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &b.AdditionalProperties)
				delete(rawMsg, key)
		case "jobProgressMetadata":
				err = unpopulate(val, "JobProgressMetadata", &b.JobProgressMetadata)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &b.LoopBackContext)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &b.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &b.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseRequest.
func (b BaseRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseRequest.
func (b *BaseRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &b.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &b.DatasourceAccessToken)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &b.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseResourceProperties.
func (b BaseResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = b.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseResourceProperties.
func (b *BaseResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BaseStatus.
func (b BaseStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", b.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", b.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseStatus.
func (b *BaseStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &b.AdditionalProperties)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &b.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &b.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BlobBackupDatasourceParameters.
func (b BlobBackupDatasourceParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containersList", b.ContainersList)
	objectMap["objectType"] = "BlobBackupDatasourceParameters"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobBackupDatasourceParameters.
func (b *BlobBackupDatasourceParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containersList":
				err = unpopulate(val, "ContainersList", &b.ContainersList)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CancelRequest.
func (c CancelRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasourceAccessToken", c.DatasourceAccessToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CancelRequest.
func (c *CancelRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &c.DatasourceAccessToken)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackBackupRequest.
func (c CommitOrRollbackBackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "backupParameters", c.BackupParameters)
	populate(objectMap, "datasource", c.Datasource)
	populate(objectMap, "datasourceAccessToken", c.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", c.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", c.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", c.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", c.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", c.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackBackupRequest.
func (c *CommitOrRollbackBackupRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &c.AdditionalProperties)
				delete(rawMsg, key)
		case "backupParameters":
				err = unpopulate(val, "BackupParameters", &c.BackupParameters)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &c.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &c.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &c.DatasourceSet)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &c.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &c.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &c.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &c.RPCatalogInitializeParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackBackupResponse.
func (c CommitOrRollbackBackupResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", c.Error)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "result", c.Result)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackBackupResponse.
func (c *CommitOrRollbackBackupResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &c.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &c.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &c.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackBackupStatus.
func (c CommitOrRollbackBackupStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "dataTransferredInBytes", c.DataTransferredInBytes)
	populate(objectMap, "datasourceSizeInBytes", c.DatasourceSizeInBytes)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", c.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", c.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackBackupStatus.
func (c *CommitOrRollbackBackupStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &c.AdditionalProperties)
				delete(rawMsg, key)
		case "dataTransferredInBytes":
				err = unpopulate(val, "DataTransferredInBytes", &c.DataTransferredInBytes)
				delete(rawMsg, key)
		case "datasourceSizeInBytes":
				err = unpopulate(val, "DatasourceSizeInBytes", &c.DatasourceSizeInBytes)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &c.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &c.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackRestoreRequest.
func (c CommitOrRollbackRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", c.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", c.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", c.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", c.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", c.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", c.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", c.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", c.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", c.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", c.RestoreToRPID)
	populate(objectMap, "sourceDatasource", c.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", c.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", c.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", c.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackRestoreRequest.
func (c *CommitOrRollbackRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &c.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &c.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &c.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &c.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				c.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &c.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &c.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &c.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &c.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &c.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &c.RestoreToRPID)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &c.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &c.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &c.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &c.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackRestoreResponse.
func (c CommitOrRollbackRestoreResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", c.Error)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "result", c.Result)
	populate(objectMap, "status", c.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackRestoreResponse.
func (c *CommitOrRollbackRestoreResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &c.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &c.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &c.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &c.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackRestoreStatus.
func (c CommitOrRollbackRestoreStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "dataTransferredInBytes", c.DataTransferredInBytes)
	populate(objectMap, "originalDatasourceSizeInBytes", c.OriginalDatasourceSizeInBytes)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", c.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", c.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackRestoreStatus.
func (c *CommitOrRollbackRestoreStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &c.AdditionalProperties)
				delete(rawMsg, key)
		case "dataTransferredInBytes":
				err = unpopulate(val, "DataTransferredInBytes", &c.DataTransferredInBytes)
				delete(rawMsg, key)
		case "originalDatasourceSizeInBytes":
				err = unpopulate(val, "OriginalDatasourceSizeInBytes", &c.OriginalDatasourceSizeInBytes)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &c.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &c.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreInfo.
func (d DataStoreInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authorizationTypeFlags", d.AuthorizationTypeFlags)
	populate(objectMap, "dataStoreId", d.DataStoreID)
	populate(objectMap, "dataStoreName", d.DataStoreName)
	populate(objectMap, "dataStoreType", d.DataStoreType)
	populate(objectMap, "dataStoreURL", d.DataStoreURL)
	populate(objectMap, "objectType", d.ObjectType)
	populate(objectMap, "storageTypeFlags", d.StorageTypeFlags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataStoreInfo.
func (d *DataStoreInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationTypeFlags":
				err = unpopulate(val, "AuthorizationTypeFlags", &d.AuthorizationTypeFlags)
				delete(rawMsg, key)
		case "dataStoreId":
				err = unpopulate(val, "DataStoreID", &d.DataStoreID)
				delete(rawMsg, key)
		case "dataStoreName":
				err = unpopulate(val, "DataStoreName", &d.DataStoreName)
				delete(rawMsg, key)
		case "dataStoreType":
				err = unpopulate(val, "DataStoreType", &d.DataStoreType)
				delete(rawMsg, key)
		case "dataStoreURL":
				err = unpopulate(val, "DataStoreURL", &d.DataStoreURL)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		case "storageTypeFlags":
				err = unpopulate(val, "StorageTypeFlags", &d.StorageTypeFlags)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataStoreParameters.
func (d DataStoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataStoreType", d.DataStoreType)
	objectMap["objectType"] = d.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataStoreParameters.
func (d *DataStoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataStoreType":
				err = unpopulate(val, "DataStoreType", &d.DataStoreType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Datasource.
func (d Datasource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", d.BaseURI)
	populate(objectMap, "datasourceType", d.DatasourceType)
	populate(objectMap, "objectType", d.ObjectType)
	populate(objectMap, "resourceID", d.ResourceID)
	populate(objectMap, "resourceLocation", d.ResourceLocation)
	populate(objectMap, "resourceName", d.ResourceName)
	populate(objectMap, "resourceProperties", d.ResourceProperties)
	populate(objectMap, "resourceType", d.ResourceType)
	populate(objectMap, "resourceUri", d.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Datasource.
func (d *Datasource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
				err = unpopulate(val, "BaseURI", &d.BaseURI)
				delete(rawMsg, key)
		case "datasourceType":
				err = unpopulate(val, "DatasourceType", &d.DatasourceType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		case "resourceID":
				err = unpopulate(val, "ResourceID", &d.ResourceID)
				delete(rawMsg, key)
		case "resourceLocation":
				err = unpopulate(val, "ResourceLocation", &d.ResourceLocation)
				delete(rawMsg, key)
		case "resourceName":
				err = unpopulate(val, "ResourceName", &d.ResourceName)
				delete(rawMsg, key)
		case "resourceProperties":
				d.ResourceProperties, err = unmarshalBaseResourcePropertiesClassification(val)
				delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &d.ResourceType)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &d.ResourceURI)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasourceSet.
func (d DatasourceSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", d.BaseURI)
	populate(objectMap, "datasourceType", d.DatasourceType)
	populate(objectMap, "objectType", d.ObjectType)
	populate(objectMap, "resourceID", d.ResourceID)
	populate(objectMap, "resourceLocation", d.ResourceLocation)
	populate(objectMap, "resourceName", d.ResourceName)
	populate(objectMap, "resourceProperties", d.ResourceProperties)
	populate(objectMap, "resourceType", d.ResourceType)
	populate(objectMap, "resourceUri", d.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasourceSet.
func (d *DatasourceSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
				err = unpopulate(val, "BaseURI", &d.BaseURI)
				delete(rawMsg, key)
		case "datasourceType":
				err = unpopulate(val, "DatasourceType", &d.DatasourceType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		case "resourceID":
				err = unpopulate(val, "ResourceID", &d.ResourceID)
				delete(rawMsg, key)
		case "resourceLocation":
				err = unpopulate(val, "ResourceLocation", &d.ResourceLocation)
				delete(rawMsg, key)
		case "resourceName":
				err = unpopulate(val, "ResourceName", &d.ResourceName)
				delete(rawMsg, key)
		case "resourceProperties":
				d.ResourceProperties, err = unmarshalBaseResourcePropertiesClassification(val)
				delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &d.ResourceType)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &d.ResourceURI)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasourceTokens.
func (d DatasourceTokens) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataPlanePrincipalId", d.DataPlanePrincipalID)
	populate(objectMap, "dataPlaneToken", d.DataPlaneToken)
	populate(objectMap, "dataPlaneTokenType", d.DataPlaneTokenType)
	populate(objectMap, "mgmtPlanePrincipalId", d.MgmtPlanePrincipalID)
	populate(objectMap, "mgmtPlaneToken", d.MgmtPlaneToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasourceTokens.
func (d *DatasourceTokens) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataPlanePrincipalId":
				err = unpopulate(val, "DataPlanePrincipalID", &d.DataPlanePrincipalID)
				delete(rawMsg, key)
		case "dataPlaneToken":
				err = unpopulate(val, "DataPlaneToken", &d.DataPlaneToken)
				delete(rawMsg, key)
		case "dataPlaneTokenType":
				err = unpopulate(val, "DataPlaneTokenType", &d.DataPlaneTokenType)
				delete(rawMsg, key)
		case "mgmtPlanePrincipalId":
				err = unpopulate(val, "MgmtPlanePrincipalID", &d.MgmtPlanePrincipalID)
				delete(rawMsg, key)
		case "mgmtPlaneToken":
				err = unpopulate(val, "MgmtPlaneToken", &d.MgmtPlaneToken)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Day.
func (d Day) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "date", d.Date)
	populate(objectMap, "isLast", d.IsLast)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Day.
func (d *Day) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "date":
				err = unpopulate(val, "Date", &d.Date)
				delete(rawMsg, key)
		case "isLast":
				err = unpopulate(val, "IsLast", &d.IsLast)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "innerError", e.InnerError)
	populate(objectMap, "isRetryable", e.IsRetryable)
	populate(objectMap, "isUserError", e.IsUserError)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "properties", e.Properties)
	populate(objectMap, "recommendedAction", e.RecommendedAction)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
				delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
				delete(rawMsg, key)
		case "innerError":
				err = unpopulate(val, "InnerError", &e.InnerError)
				delete(rawMsg, key)
		case "isRetryable":
				err = unpopulate(val, "IsRetryable", &e.IsRetryable)
				delete(rawMsg, key)
		case "isUserError":
				err = unpopulate(val, "IsUserError", &e.IsUserError)
				delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &e.Properties)
				delete(rawMsg, key)
		case "recommendedAction":
				err = unpopulate(val, "RecommendedAction", &e.RecommendedAction)
				delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InnerError.
func (i InnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", i.AdditionalInfo)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "embeddedInnerError", i.EmbeddedInnerError)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InnerError.
func (i *InnerError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &i.AdditionalInfo)
				delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &i.Code)
				delete(rawMsg, key)
		case "embeddedInnerError":
				err = unpopulate(val, "EmbeddedInnerError", &i.EmbeddedInnerError)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemLevelRestoreCriteria.
func (i ItemLevelRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = i.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemLevelRestoreCriteria.
func (i *ItemLevelRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &i.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemPathBasedRestoreCriteria.
func (i ItemPathBasedRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isPathRelativeToBackupItem", i.IsPathRelativeToBackupItem)
	populate(objectMap, "itemPath", i.ItemPath)
	objectMap["objectType"] = "ItemPathBasedRestoreCriteria"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemPathBasedRestoreCriteria.
func (i *ItemPathBasedRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isPathRelativeToBackupItem":
				err = unpopulate(val, "IsPathRelativeToBackupItem", &i.IsPathRelativeToBackupItem)
				delete(rawMsg, key)
		case "itemPath":
				err = unpopulate(val, "ItemPath", &i.ItemPath)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &i.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobProgressMetadata.
func (j JobProgressMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataTransferredInBytes", j.DataTransferredInBytes)
	populate(objectMap, "percentComplete", j.PercentComplete)
	populate(objectMap, "timeRemainingInMinutes", j.TimeRemainingInMinutes)
	populate(objectMap, "totalDataInBytes", j.TotalDataInBytes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProgressMetadata.
func (j *JobProgressMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataTransferredInBytes":
				err = unpopulate(val, "DataTransferredInBytes", &j.DataTransferredInBytes)
				delete(rawMsg, key)
		case "percentComplete":
				err = unpopulate(val, "PercentComplete", &j.PercentComplete)
				delete(rawMsg, key)
		case "timeRemainingInMinutes":
				err = unpopulate(val, "TimeRemainingInMinutes", &j.TimeRemainingInMinutes)
				delete(rawMsg, key)
		case "totalDataInBytes":
				err = unpopulate(val, "TotalDataInBytes", &j.TotalDataInBytes)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesPVRestoreCriteria.
func (k KubernetesPVRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", k.Name)
	objectMap["objectType"] = "KubernetesPVRestoreCriteria"
	populate(objectMap, "storageClassName", k.StorageClassName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesPVRestoreCriteria.
func (k *KubernetesPVRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &k.Name)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &k.ObjectType)
				delete(rawMsg, key)
		case "storageClassName":
				err = unpopulate(val, "StorageClassName", &k.StorageClassName)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesStorageClassRestoreCriteria.
func (k KubernetesStorageClassRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "KubernetesStorageClassRestoreCriteria"
	populate(objectMap, "provisioner", k.Provisioner)
	populate(objectMap, "selectedStorageClassName", k.SelectedStorageClassName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesStorageClassRestoreCriteria.
func (k *KubernetesStorageClassRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &k.ObjectType)
				delete(rawMsg, key)
		case "provisioner":
				err = unpopulate(val, "Provisioner", &k.Provisioner)
				delete(rawMsg, key)
		case "selectedStorageClassName":
				err = unpopulate(val, "SelectedStorageClassName", &k.SelectedStorageClassName)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyInfo.
func (p PolicyInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "policyName", p.PolicyName)
	populate(objectMap, "policyVersion", p.PolicyVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyInfo.
func (p *PolicyInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "policyName":
				err = unpopulate(val, "PolicyName", &p.PolicyName)
				delete(rawMsg, key)
		case "policyVersion":
				err = unpopulate(val, "PolicyVersion", &p.PolicyVersion)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyParameters.
func (p PolicyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupDatasourceParametersList", p.BackupDatasourceParametersList)
	populate(objectMap, "dataStoreParametersList", p.DataStoreParametersList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyParameters.
func (p *PolicyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupDatasourceParametersList":
				p.BackupDatasourceParametersList, err = unmarshalBackupDatasourceParametersClassificationArray(val)
				delete(rawMsg, key)
		case "dataStoreParametersList":
				p.DataStoreParametersList, err = unmarshalDataStoreParametersClassificationArray(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectionRequestBase.
func (p ProtectionRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", p.AdditionalProperties)
	populate(objectMap, "backupSettings", p.BackupSettings)
	populate(objectMap, "datasource", p.Datasource)
	populate(objectMap, "datasourceAccessToken", p.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", p.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", p.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectionRequestBase.
func (p *ProtectionRequestBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &p.AdditionalProperties)
				delete(rawMsg, key)
		case "backupSettings":
				err = unpopulate(val, "BackupSettings", &p.BackupSettings)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &p.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &p.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &p.DatasourceSet)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &p.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RangeBasedItemLevelRestoreCriteria.
func (r RangeBasedItemLevelRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "maxMatchingValue", r.MaxMatchingValue)
	populate(objectMap, "minMatchingValue", r.MinMatchingValue)
	objectMap["objectType"] = "RangeBasedItemLevelRestoreCriteria"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RangeBasedItemLevelRestoreCriteria.
func (r *RangeBasedItemLevelRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxMatchingValue":
				err = unpopulate(val, "MaxMatchingValue", &r.MaxMatchingValue)
				delete(rawMsg, key)
		case "minMatchingValue":
				err = unpopulate(val, "MinMatchingValue", &r.MinMatchingValue)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &r.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RefreshTokensRequest.
func (r RefreshTokensRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasourceAccessToken", r.DatasourceAccessToken)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RefreshTokensRequest.
func (r *RefreshTokensRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &r.DatasourceAccessToken)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Response.
func (r Response) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", r.Error)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Response.
func (r *Response) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &r.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &r.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreRequest.
func (r RestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", r.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", r.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", r.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", r.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", r.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", r.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", r.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", r.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", r.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", r.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", r.RestoreToRPID)
	populate(objectMap, "sourceDatasource", r.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", r.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", r.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", r.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreRequest.
func (r *RestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &r.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &r.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &r.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &r.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				r.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &r.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &r.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &r.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &r.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &r.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &r.RestoreToRPID)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &r.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &r.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &r.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &r.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreRequestBase.
func (r RestoreRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", r.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", r.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", r.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", r.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", r.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", r.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", r.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", r.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", r.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", r.RestoreToRPID)
	populate(objectMap, "sourceDatasource", r.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", r.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", r.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", r.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreRequestBase.
func (r *RestoreRequestBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &r.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &r.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &r.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &r.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				r.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &r.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &r.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &r.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &r.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &r.RestoreToRPID)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &r.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &r.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &r.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &r.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreResponse.
func (r RestoreResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", r.Error)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "result", r.Result)
	populate(objectMap, "status", r.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreResponse.
func (r *RestoreResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &r.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &r.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &r.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreStatus.
func (r RestoreStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", r.AdditionalProperties)
	populate(objectMap, "jobProgressMetadata", r.JobProgressMetadata)
	populate(objectMap, "loopBackContext", r.LoopBackContext)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", r.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", r.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreStatus.
func (r *RestoreStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &r.AdditionalProperties)
				delete(rawMsg, key)
		case "jobProgressMetadata":
				err = unpopulate(val, "JobProgressMetadata", &r.JobProgressMetadata)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &r.LoopBackContext)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &r.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &r.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RetentionTag.
func (r RetentionTag) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eTag", r.ETag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "tagName", r.TagName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetentionTag.
func (r *RetentionTag) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
				err = unpopulate(val, "ETag", &r.ETag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
				delete(rawMsg, key)
		case "tagName":
				err = unpopulate(val, "TagName", &r.TagName)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleBasedBackupCriteria.
func (s ScheduleBasedBackupCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "absoluteCriteria", s.AbsoluteCriteria)
	populate(objectMap, "daysOfMonth", s.DaysOfMonth)
	populate(objectMap, "daysOfTheWeek", s.DaysOfTheWeek)
	populate(objectMap, "monthsOfYear", s.MonthsOfYear)
	objectMap["objectType"] = "ScheduleBasedBackupCriteria"
	aux := make([]*timeRFC3339, len(s.ScheduleTimes), len(s.ScheduleTimes))
	for i := 0; i < len(s.ScheduleTimes); i++ {
		aux[i] = (*timeRFC3339)(s.ScheduleTimes[i])
	}
	populate(objectMap, "scheduleTimes", aux)
	populate(objectMap, "weeksOfTheMonth", s.WeeksOfTheMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleBasedBackupCriteria.
func (s *ScheduleBasedBackupCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "absoluteCriteria":
				err = unpopulate(val, "AbsoluteCriteria", &s.AbsoluteCriteria)
				delete(rawMsg, key)
		case "daysOfMonth":
				err = unpopulate(val, "DaysOfMonth", &s.DaysOfMonth)
				delete(rawMsg, key)
		case "daysOfTheWeek":
				err = unpopulate(val, "DaysOfTheWeek", &s.DaysOfTheWeek)
				delete(rawMsg, key)
		case "monthsOfYear":
				err = unpopulate(val, "MonthsOfYear", &s.MonthsOfYear)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &s.ObjectType)
				delete(rawMsg, key)
		case "scheduleTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "ScheduleTimes", &aux)
			for _, au := range aux {
				s.ScheduleTimes = append(s.ScheduleTimes, (*time.Time)(au))
			}
				delete(rawMsg, key)
		case "weeksOfTheMonth":
				err = unpopulate(val, "WeeksOfTheMonth", &s.WeeksOfTheMonth)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleBasedTriggerContext.
func (s ScheduleBasedTriggerContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "ScheduleBasedTriggerContext"
	populate(objectMap, "schedule", s.Schedule)
	populate(objectMap, "taggingCriteria", s.TaggingCriteria)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleBasedTriggerContext.
func (s *ScheduleBasedTriggerContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &s.ObjectType)
				delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &s.Schedule)
				delete(rawMsg, key)
		case "taggingCriteria":
				err = unpopulate(val, "TaggingCriteria", &s.TaggingCriteria)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartProtectionRequest.
func (s StartProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "backupSettings", s.BackupSettings)
	populate(objectMap, "datasource", s.Datasource)
	populate(objectMap, "datasourceAccessToken", s.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", s.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", s.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartProtectionRequest.
func (s *StartProtectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &s.AdditionalProperties)
				delete(rawMsg, key)
		case "backupSettings":
				err = unpopulate(val, "BackupSettings", &s.BackupSettings)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &s.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &s.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &s.DatasourceSet)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &s.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartProtectionResponse.
func (s StartProtectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", s.Error)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "result", s.Result)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartProtectionResponse.
func (s *StartProtectionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &s.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &s.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &s.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartProtectionStatus.
func (s StartProtectionStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", s.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", s.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StartProtectionStatus.
func (s *StartProtectionStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &s.AdditionalProperties)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &s.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &s.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StopProtectionRequest.
func (s StopProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "backupSettings", s.BackupSettings)
	populate(objectMap, "datasource", s.Datasource)
	populate(objectMap, "datasourceAccessToken", s.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", s.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", s.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StopProtectionRequest.
func (s *StopProtectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &s.AdditionalProperties)
				delete(rawMsg, key)
		case "backupSettings":
				err = unpopulate(val, "BackupSettings", &s.BackupSettings)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &s.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &s.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &s.DatasourceSet)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &s.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StopProtectionResponse.
func (s StopProtectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", s.Error)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "result", s.Result)
	populate(objectMap, "status", s.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StopProtectionResponse.
func (s *StopProtectionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &s.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &s.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &s.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StopProtectionStatus.
func (s StopProtectionStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", s.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", s.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StopProtectionStatus.
func (s *StopProtectionStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &s.AdditionalProperties)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &s.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &s.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TaggingCriteria.
func (t TaggingCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "criteria", t.Criteria)
	populate(objectMap, "isDefault", t.IsDefault)
	populate(objectMap, "tagInfo", t.TagInfo)
	populate(objectMap, "taggingPriority", t.TaggingPriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaggingCriteria.
func (t *TaggingCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "criteria":
				t.Criteria, err = unmarshalBackupCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "isDefault":
				err = unpopulate(val, "IsDefault", &t.IsDefault)
				delete(rawMsg, key)
		case "tagInfo":
				err = unpopulate(val, "TagInfo", &t.TagInfo)
				delete(rawMsg, key)
		case "taggingPriority":
				err = unpopulate(val, "TaggingPriority", &t.TaggingPriority)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetDetails.
func (t TargetDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "filePrefix", t.FilePrefix)
	populate(objectMap, "restoreTargetLocationType", t.RestoreTargetLocationType)
	populate(objectMap, "url", t.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetDetails.
func (t *TargetDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "filePrefix":
				err = unpopulate(val, "FilePrefix", &t.FilePrefix)
				delete(rawMsg, key)
		case "restoreTargetLocationType":
				err = unpopulate(val, "RestoreTargetLocationType", &t.RestoreTargetLocationType)
				delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &t.URL)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TriggerContext.
func (t TriggerContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = t.ObjectType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TriggerContext.
func (t *TriggerContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &t.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateProtectionRequest.
func (u UpdateProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", u.AdditionalProperties)
	populate(objectMap, "backupSettings", u.BackupSettings)
	populate(objectMap, "datasource", u.Datasource)
	populate(objectMap, "datasourceAccessToken", u.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", u.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", u.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateProtectionRequest.
func (u *UpdateProtectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &u.AdditionalProperties)
				delete(rawMsg, key)
		case "backupSettings":
				err = unpopulate(val, "BackupSettings", &u.BackupSettings)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &u.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &u.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &u.DatasourceSet)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &u.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateProtectionResponse.
func (u UpdateProtectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", u.Error)
	populate(objectMap, "id", u.ID)
	populate(objectMap, "result", u.Result)
	populate(objectMap, "status", u.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateProtectionResponse.
func (u *UpdateProtectionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &u.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &u.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &u.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &u.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateProtectionStatus.
func (u UpdateProtectionStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", u.AdditionalProperties)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", u.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", u.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateProtectionStatus.
func (u *UpdateProtectionStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &u.AdditionalProperties)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &u.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &u.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForBackupRequest.
func (v ValidateForBackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "backupParameters", v.BackupParameters)
	populate(objectMap, "datasource", v.Datasource)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", v.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", v.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", v.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForBackupRequest.
func (v *ValidateForBackupRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "backupParameters":
				err = unpopulate(val, "BackupParameters", &v.BackupParameters)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &v.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &v.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &v.DatasourceSet)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &v.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &v.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &v.RPCatalogInitializeParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForBackupResponse.
func (v ValidateForBackupResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", v.Error)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "result", v.Result)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForBackupResponse.
func (v *ValidateForBackupResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &v.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &v.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &v.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &v.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForBackupStatus.
func (v ValidateForBackupStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "loopBackContext", v.LoopBackContext)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", v.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", v.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForBackupStatus.
func (v *ValidateForBackupStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &v.LoopBackContext)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &v.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &v.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForProtectionRequest.
func (v ValidateForProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "backupSettings", v.BackupSettings)
	populate(objectMap, "datasource", v.Datasource)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", v.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForProtectionRequest.
func (v *ValidateForProtectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "backupSettings":
				err = unpopulate(val, "BackupSettings", &v.BackupSettings)
				delete(rawMsg, key)
		case "datasource":
				err = unpopulate(val, "Datasource", &v.Datasource)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &v.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datasourceSet":
				err = unpopulate(val, "DatasourceSet", &v.DatasourceSet)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &v.JobLibraryInitializationParams)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForProtectionResponse.
func (v ValidateForProtectionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", v.Error)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "result", v.Result)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForProtectionResponse.
func (v *ValidateForProtectionResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &v.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &v.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &v.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &v.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForProtectionStatus.
func (v ValidateForProtectionStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", v.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", v.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForProtectionStatus.
func (v *ValidateForProtectionStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &v.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &v.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForRestoreRequest.
func (v ValidateForRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", v.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", v.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", v.ILRRestoreCriteria)
	populate(objectMap, "isValidateOnlyOperation", v.IsValidateOnlyOperation)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", v.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", v.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", v.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", v.RestoreToRPID)
	populate(objectMap, "sourceDatasource", v.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", v.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", v.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", v.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForRestoreRequest.
func (v *ValidateForRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &v.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &v.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &v.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				v.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "isValidateOnlyOperation":
				err = unpopulate(val, "IsValidateOnlyOperation", &v.IsValidateOnlyOperation)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &v.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &v.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &v.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &v.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &v.RestoreToRPID)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &v.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &v.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &v.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &v.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForRestoreResponse.
func (v ValidateForRestoreResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", v.Error)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "result", v.Result)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForRestoreResponse.
func (v *ValidateForRestoreResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &v.Error)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &v.ID)
				delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &v.Result)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &v.Status)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForRestoreStatus.
func (v ValidateForRestoreStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "loopBackContext", v.LoopBackContext)
	populate(objectMap, "retryAfterOnRetryableErrorInSeconds", v.RetryAfterOnRetryableErrorInSeconds)
	populate(objectMap, "telemetryData", v.TelemetryData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForRestoreStatus.
func (v *ValidateForRestoreStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &v.LoopBackContext)
				delete(rawMsg, key)
		case "retryAfterOnRetryableErrorInSeconds":
				err = unpopulate(val, "RetryAfterOnRetryableErrorInSeconds", &v.RetryAfterOnRetryableErrorInSeconds)
				delete(rawMsg, key)
		case "telemetryData":
				err = unpopulate(val, "TelemetryData", &v.TelemetryData)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VmwareVMProperties.
func (v VmwareVMProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	objectMap["objectType"] = "VmwareVMProperties"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VmwareVMProperties.
func (v *VmwareVMProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceUuid":
				err = unpopulate(val, "InstanceUUID", &v.InstanceUUID)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &v.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

